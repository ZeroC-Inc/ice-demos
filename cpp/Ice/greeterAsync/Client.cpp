// Copyright (c) ZeroC, Inc.

#include "Greeter.h"

#include <cstdlib>
#include <future>
#include <iostream>

using namespace std;

int
main(int argc, char* argv[])
{
    // Figure out my name.
    const char* name = getenv("USER");
    if (name == nullptr)
    {
        name = getenv("USERNAME");
    }
    if (name == nullptr)
    {
        name = "alice";
    }

    // Create an Ice communicator to initialize the Ice runtime. The CommunicatorHolder is a RAII helper that creates
    // the communicator in its constructor and destroys it when it goes out of scope.
    const Ice::CommunicatorHolder communicatorHolder{argc, argv};
    const Ice::CommunicatorPtr& communicator = communicatorHolder.communicator();

    // GreeterPrx is a class generated by the Slice compiler. We create a proxy from a communicator and a "stringified
    // proxy" with the address of the target object.
    // If you run the server on a different computer, replace localhost in the string below with the server's hostname
    // or IP address.
    VisitorCenter::GreeterPrx greeter{communicator, "greeter:tcp -h localhost -p 4061"};

    // Send a request using the asynchronous callback API provided by GreeterPrx.
    promise<void> promise;
    greeter->greetAsync(
        name,
        [&promise](string_view greeting)
        {
            cout << greeting << endl;
            promise.set_value();
        },
        [&promise](std::exception_ptr exceptionPtr)
        {
            try
            {
                rethrow_exception(exceptionPtr);
            }
            catch (const std::exception& e)
            {
                cerr << "Error: " << e.what() << endl;
            }
            promise.set_value();
        });

    // Wait for the response/exception callback to be called.
    promise.get_future().get();

    // Send a second request using the asynchronous future API provided by GreeterPrx.
    future<string> greeting = greeter->greetAsync(name);
    cout << greeting.get() << endl;

    return 0;
}
